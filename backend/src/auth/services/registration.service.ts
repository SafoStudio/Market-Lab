import {
  BadRequestException, ConflictException,
  Injectable, Inject, NotFoundException,
} from '@nestjs/common';
import { ConfigService } from '@nestjs/config';

// DTOs & types
import {
  RegisterDto,
  RegisterInitialDto,
  RegCompleteDto,
  RegSupplierProfileDto,
  RegCustomerProfileDto,
} from '../types';
import { Role } from '@shared/types';
import type { DocumentStorage } from '@domain/suppliers/types';

// Domain entities
import { UserDomainEntity } from '@domain/users/user.entity';
import { CustomerDomainEntity } from '@domain/customers/customer.entity';
import { SupplierDomainEntity } from '@domain/suppliers/supplier.entity';

// Domain repositories (interfaces)
import { UserRepository } from '@domain/users/user.repository';
import { CustomerRepository } from '@domain/customers/customer.repository';
import { SupplierRepository } from '@domain/suppliers/supplier.repository';

// Domain services
import { NotificationService } from '@domain/notifications/notification.service';
import { AddressService } from '@domain/addresses/address.service';
import { TranslationService } from '@domain/translations/translation.service';

// Auth services
import { EncryptService } from '../encrypt/encrypt.service';
import { TokenService } from '../tokens/token.service';

// Domain enums and types
import { USER_ROLES, USER_STATUS, UserRole, UserStatus } from '@domain/users/types';
import { CUSTOMER_STATUS, CustomerStatus } from '@domain/customers/types';
import { SUPPLIER_STATUS, SupplierStatus } from '@domain/suppliers/types';


@Injectable()
export class RegistrationService {
  private readonly frontendUrl: string;

  constructor(
    private readonly encrypt: EncryptService,
    private readonly tokenService: TokenService,
    private readonly notificationService: NotificationService,
    private readonly addressService: AddressService,
    private readonly config: ConfigService,
    private readonly translationService: TranslationService,

    @Inject('UserRepository')
    private readonly userRepository: UserRepository,

    @Inject('CustomerRepository')
    private readonly customerRepository: CustomerRepository,

    @Inject('SupplierRepository')
    private readonly supplierRepository: SupplierRepository,

    @Inject('DocumentStorage')
    private readonly documentStorage: DocumentStorage,
  ) {
    this.frontendUrl = this.config.get<string>('FRONTEND_URL')!;
  }

  /**
   * Initial registration for all user types
   * Creates user with basic info and sends verification email
   */
  async registerInitial(dto: RegisterInitialDto) {
    const { email, password, googleId } = dto;

    // Check if user already exists using domain repository
    const existingUser = await this.userRepository.findByEmail(email);
    if (existingUser) {
      throw new ConflictException('Email already registered');
    }

    // Create domain user entity (ID will be generated by repository)
    const user = new UserDomainEntity(
      '', // Empty ID - repository will generate it
      email,
      password ? await this.encrypt.hash(password) : null,
      [],
      USER_STATUS.ACTIVE as UserStatus,
      !!googleId, // Google users are pre-verified
      false, // Registration not complete yet
      undefined, // lastLoginAt
      new Date(), // createdAt
      new Date(), // updatedAt
    );

    // Save user through repository
    const savedUser = await this.userRepository.create(user);

    // Send verification email only for non-Google registration
    if (!googleId) {
      await this._sendVerificationEmail(savedUser);
    }

    return this._generateUserResponse(savedUser);
  }

  /**
   * Complete registration process with user details and documents
   */
  async completeRegistration(
    userId: string,
    dto: RegCompleteDto,
    documents?: Express.Multer.File[]
  ) {
    // Find user using domain repository
    const user = await this.userRepository.findById(userId);
    if (!user) throw new NotFoundException('User not found');
    const { role, profile } = dto;
    // Convert shared Role to domain UserRole
    const userRole = this._convertRoleToUserRole(role);
    // Check if user already has this role using domain method
    if (user.hasRole(userRole)) throw new BadRequestException(`User already has ${role} role`);
    // Add role using domain method
    user.addRole(userRole);
    // Complete registration using domain method
    if (!user.regComplete) user.completeRegistration([userRole]);

    // Update user through repository
    await this.userRepository.update(userId, {
      roles: user.roles,
      regComplete: user.regComplete,
      updatedAt: new Date(),
    });

    // Handle customer profile creation
    if (role === Role.CUSTOMER) {
      await this._createCustomerProfile(userId, profile as RegCustomerProfileDto);
    }

    // Handle supplier profile creation
    if (role === Role.SUPPLIER) {
      await this._createSupplierProfile(
        userId,
        user.email,
        profile as RegSupplierProfileDto,
        documents
      );
    }

    return this._generateUserResponse(user);
  }

  /**
   * Admin registration (creates fully registered users)
   */
  async registerAdmin(dto: RegisterDto) {
    const { email, password, role, profile } = dto;

    // Check existing user using domain repository
    const existingUser = await this.userRepository.findByEmail(email);
    if (existingUser) throw new ConflictException('Email already registered');
    // Convert shared Role to domain UserRole
    const userRole = this._convertRoleToUserRole(role);
    // Create admin user (ID will be generated by repository)
    const user = new UserDomainEntity(
      '', // Empty ID - repository will generate it
      email,
      await this.encrypt.hash(password),
      [userRole],
      USER_STATUS.ACTIVE as UserStatus,
      true, // Admin users are auto-verified
      true, // Registration complete
      undefined, // lastLoginAt
      new Date(), // createdAt
      new Date(), // updatedAt
    );

    // Save user through repository
    const savedUser = await this.userRepository.create(user);

    // Create profile based on role
    if (role === Role.CUSTOMER) {
      await this._createCustomerProfile(savedUser.id, profile as RegCustomerProfileDto);
    } else if (role === Role.SUPPLIER) {
      await this._createSupplierProfile(
        savedUser.id,
        savedUser.email,
        profile as RegSupplierProfileDto,
        []
      );
    }

    return this._generateUserResponse(savedUser);
  }

  /**
   * Create customer profile entity
   */
  private async _createCustomerProfile(
    userId: string,
    profile: RegCustomerProfileDto
  ) {
    // Check if customer profile already exists
    const existingProfile = await this.customerRepository.findByUserId(userId);
    if (existingProfile) throw new BadRequestException('Customer profile already exists');
    // Create domain customer entity (ID will be generated by repository)
    const customer = new CustomerDomainEntity(
      '', // Empty ID - repository will generate it
      userId,
      profile.firstName,
      profile.lastName,
      profile.phone,
      profile.birthday ? new Date(profile.birthday) : null,
      CUSTOMER_STATUS.ACTIVE as CustomerStatus,
      new Date(), // createdAt
      new Date()  // updatedAt
    );

    // Save customer through repository
    const savedCustomer = await this.customerRepository.create(customer);

    // Create address if provided
    if (profile.address) {
      await this.addressService.createAddress({
        entityId: savedCustomer.id,
        entityType: Role.CUSTOMER,
        country: profile.address.country,
        city: profile.address.city,
        street: profile.address.street,
        building: profile.address.building,
        postalCode: profile.address.postalCode,
        state: profile.address.state,
        lat: profile.address.lat,
        lng: profile.address.lng,
        isPrimary: true,
      });
    }

    return savedCustomer;
  }

  /**
   * Create supplier profile with document upload
   */
  private async _createSupplierProfile(
    userId: string,
    email: string,
    profile: RegSupplierProfileDto,
    documents?: Express.Multer.File[]
  ) {
    // Check if supplier profile already exists
    const existingProfile = await this.supplierRepository.findByUserId(userId);
    if (existingProfile) throw new BadRequestException('Supplier profile already exists');

    let documentUrls: string[] = [];

    // Upload documents to S3 if provided
    if (documents && documents.length > 0) {
      documentUrls = await this.documentStorage.uploadMany(
        documents,
        profile.companyName
      );
    }

    const allDocuments = [...documentUrls, ...(profile.documents ?? [])];

    // Create domain supplier entity (ID will be generated by repository)
    const supplier = new SupplierDomainEntity(
      '', // Empty ID - repository will generate it
      userId,
      profile.companyName,
      profile.registrationNumber,
      profile.phone,
      profile.firstName,
      profile.lastName,
      profile.description || '',
      allDocuments,
      SUPPLIER_STATUS.PENDING as SupplierStatus,
      undefined, // translations (will be handled separately)
      new Date(), // createdAt
      new Date()  // updatedAt
    );

    // Save supplier through repository
    const savedSupplier = await this.supplierRepository.create(supplier);

    // Save translations if provided
    if (profile.translations) {
      await this.translationService.saveTranslations(
        savedSupplier.id,
        'supplier',
        profile.translations
      );
    }

    // Create address if provided
    if (profile.address) {
      await this.addressService.createAddress({
        entityId: savedSupplier.id,
        entityType: Role.SUPPLIER,
        country: profile.address.country,
        city: profile.address.city,
        street: profile.address.street,
        building: profile.address.building,
        postalCode: profile.address.postalCode,
        state: profile.address.state,
        lat: profile.address.lat,
        lng: profile.address.lng,
        isPrimary: true,
      });
    }

    return savedSupplier;
  }

  /**
   * Send verification email to user
   */
  private async _sendVerificationEmail(user: UserDomainEntity) {
    try {
      const token = await this.tokenService.createToken(
        user.id,
        'email_verification',
        24
      );
      const verificationLink = `${this.frontendUrl}/auth/verify-email?token=${token}`;

      await this.notificationService.sendVerificationEmail(
        user.email,
        verificationLink
      );
    } catch (error) {
      console.error('Failed to send verification email:', error);
    }
  }

  /**
   * Generate standardized user response without password
   */
  private _generateUserResponse(user: UserDomainEntity) {
    const { passwordHash, ...safeUser } = user;
    return { user: safeUser };
  }

  /**
   * Convert shared Role enum to domain UserRole
   */
  private _convertRoleToUserRole(role: Role): UserRole {
    const roleMap: Partial<Record<Role, UserRole>> = {
      [Role.CUSTOMER]: USER_ROLES.CUSTOMER,
      [Role.SUPPLIER]: USER_ROLES.SUPPLIER,
      [Role.ADMIN]: USER_ROLES.ADMIN,
      [Role.SUPER_ADMIN]: USER_ROLES.ADMIN,
      [Role.MODERATOR]: USER_ROLES.ADMIN,
      [Role.SUPPORT]: USER_ROLES.ADMIN,
      [Role.GUEST]: USER_ROLES.ADMIN,
    };

    return roleMap[role] || USER_ROLES.CUSTOMER;
  }
}